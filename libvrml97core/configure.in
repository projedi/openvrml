dnl libvrml97core - configure.in

dnl Process this file with autoconf to produce a configure script.

AC_INIT(src/vrml97/VrmlNode.cpp)

PACKAGE=libvrml97core
VERSION="0.8.0"
LIBVRML97CORE_SO_VERSION=0:0:0

dnl Initialize automake stuff
AM_INIT_AUTOMAKE($PACKAGE, $VERSION)

dnl Specify a configuration file (autogenerated using template source/config.h.in)
AM_CONFIG_HEADER(config.h)

AM_MAINTAINER_MODE

dnl Set default language to C (set to C++ later)
AC_LANG_C

dnl Make sure we can compile stuff
dnl ==================================================================
AC_PROG_CC
AC_PROG_CPP
AC_STDC_HEADERS
AM_PROG_LEX
AC_PROG_YACC
AM_PROG_LIBTOOL



dnl Now begin Checking for various libraries
dnl ==================================================================

AC_CHECK_LIB(jpeg, jpeg_read_header, 
  AC_CHECK_HEADER(jpeglib.h,
    [
      LIBS="$LIBS -ljpeg"
      AC_DEFINE(HAVE_LIBJPEG)
    ],
    AC_MSG_ERROR([jpeglib.h not found. Check config.log for details.])
  ),
  AC_MSG_ERROR([libjpeg not found. Check config.log for details.])
)

dnl Test for zlib
AC_CHECK_LIB(z, zlibVersion,
  AC_CHECK_HEADER(zlib.h,
    [
      LIBS="$LIBS -lz"
      AC_DEFINE(HAVE_ZLIB)
    ],
    AC_MSG_ERROR([zlib.h not found. Check config.log for details.])
  ),
  AC_MSG_ERROR([zlib not found. Check config.log for details.])
)

dnl Test for libpng
AC_CHECK_LIB(png, png_read_info,
  AC_CHECK_HEADER(png.h,
    [
      LIBS="$LIBS -lpng"
      AC_DEFINE(HAVE_LIBPNG)
    ],
    AC_MSG_ERROR([png.h not found. Check config.log for details.])
  ),
  AC_MSG_ERROR([libpng not found. Check config.log for details.])
)

dnl Now test for a bunch of C++ compiler capabilities...
dnl ==================================================================
AC_PROG_CXX
AC_LANG_CPLUSPLUS


dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports bool(required))
AC_TRY_COMPILE(
[
],[
   bool b=true;
   bool b1=false;
],[
  ac_bool=yes
dnl  AC_DEFINE(HAVE_NATIVE_BOOL)
],[
  config_error=yes
  AC_WARN(bool type is not supported by your compiler)
])
AC_MSG_RESULT([$ac_bool])

dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports const_cast (required))
AC_TRY_COMPILE(
[
   class foo;
],[
   const foo *c=0;
   foo *c1=const_cast<foo*>(c);
],[
  ac_const_cast=yes
dnl  AC_DEFINE(HAVE_CONST_CAST)
],[
  AC_WARN(C++ compiler const_cast<> does not work)
  config_error=yes
])
AC_MSG_RESULT([$ac_const_cast])




dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports member templates)
AC_TRY_COMPILE(
[
class foo
{
public:
  template <class T> void method(T t);
};

template <class T> void foo::method(T t) {t = 0;}
],[
],[
   ac_member_templates=yes
dnl   AC_DEFINE(HAVE_MEMBER_TEMPLATES)
   AC_MSG_RESULT([$ac_member_templates])
],[
  ac_member_templates=no
  AC_MSG_RESULT([$ac_member_templates])
  AC_MSG_WARN([Test for member templates failed. If your compiler does support member templates, see config.log to figure out why the test failed.])
])



dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports partial specialization)
AC_TRY_COMPILE(
[
template<class T, class K>
class k {
public:
};
template<class T> class k<void,T> { };
],[
  k<float, float> b;
  k<void,void> a;
],[
  ac_partial_specialization=yes
dnl  AC_DEFINE(HAVE_PARTIAL_SPECIALIZATION)
],[
  ac_partial_specialization=no
])
AC_MSG_RESULT([$ac_partial_specialization])


dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports static data inside templates)
AC_TRY_LINK(
[
template<class T>
class foo { public: static T a; };
template<class T>
static T foo<T>::a=0;
],[
  foo<int> b;
],[
  ac_static_templates=yes
],[
dnl  AC_DEFINE(HAVE_NO_STATIC_TEMPLATES)
  ac_static_templates=no
])
AC_MSG_RESULT([$ac_static_templates])


dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports templates well enough(required))
AC_TRY_LINK(
[
class foo { public: int a(float,int,int,foo*,foo**) { return 0; } };
template<class rettype, class T, class P1, class P2, class P3, class P4, class P5>
class k {
public:
   rettype (T::*method)(P1,P2,P3,P4,P5);
};
],[
  k<int,foo,float,int,int,foo*,foo**> a;
],[
],[
  config_error=yes
  AC_WARN(your C++ compiler does not support templates well enough)
])
AC_MSG_RESULT([yes])


dnl ==================================================================
AC_MSG_CHECKING(if required compiler features are available)
if test "x$config_error" = xyes ; then
  AC_MSG_RESULT([no])
  AC_MSG_ERROR(Your compiler is not powerful enough to compile libVrml97. If you think that that your compiler is powerful enough, then see config.log for more information about why things failed.)
fi
AC_MSG_RESULT([yes])

CFLAGS=""
JSCFLAGS="-DXP_UNIX"

dnl Debug or not
AC_ARG_ENABLE(debug, [  --enable-debug ])
if test "${enable_debug}" = "yes"; then
  CFLAGS="$CFLAGS -g"
else
  CFLAGS="$CFLAGS -DNDEBUG"
fi

dnl Optimized or not
AC_ARG_ENABLE(optimized, [  --disable-optimized ])
if test "${enable_optimized}" != "no"; then
  CFLAGS="$CFLAGS -O2"
fi

AC_SUBST(CFLAGS)
AC_SUBST(JSCFLAGS)
AC_SUBST(LIBVRML97CORE_SO_VERSION)

AC_OUTPUT(Makefile \
          m4/Makefile \
          src/Makefile \
          src/vrml97/Makefile \
          src/vrml97/libjs/Makefile
          src/vrml97/libjs/fdlibm/Makefile)

