dnl			 LibVRML97 - configure.in

dnl Process this file with autoconf to produce a configure script.

AC_INIT(src/vrml97/VrmlNode.cpp)

dnl How version numbering works...
dnl +1 : ? : +1  == new interface that does not break old one
dnl +1 : ? : 0   == new interface that breaks old one
dnl  ? : ? : 0   == no new interfaces, but breaks apps
dnl  ? :+1 : ?   == just internal changes, nothing breaks but might work better
LIBVRML_MAJOR_VERSION=0
LIBVRML_MINOR_VERSION=8
LIBVRML_MICRO_VERSION=0

AC_DEFINE_UNQUOTED(LIBVRML_MAJOR_VERSION, $LIBVRML_MAJOR_VERSION)
AC_DEFINE_UNQUOTED(LIBVRML_MINOR_VERSION, $LIBVRML_MINOR_VERSION)
AC_DEFINE_UNQUOTED(LIBVRML_MICRO_VERSION, $LIBVRML_MICRO_VERSION)
LIBVRML_VERSION=$LIBVRML_MAJOR_VERSION.$LIBVRML_MINOR_VERSION.$LIBVRML_MICRO_VERSION
AC_SUBST(LIBVRML_VERSION)
dnl AC_DEFINE(LIBVRML_VERSION)

dnl For automake.
PACKAGE=libvrml97
VERSION=$LIBVRML_VERSION

dnl Initialize automake stuff
AM_INIT_AUTOMAKE($PACKAGE, $VERSION)

dnl Specify a configuration file (autogenerated using template source/config.h.in)
AM_CONFIG_HEADER(config.h)

AM_MAINTAINER_MODE

dnl Set default language to C (set to C++ later)
AC_LANG_C

dnl Check for the existance of a bunch of programs in no particular order
dnl ==================================================================
dnl AC_PROG_RANLIB


dnl Make sure we can compile stuff
dnl ==================================================================
AC_PROG_CC
AC_PROG_CPP
AC_STDC_HEADERS
AM_PROG_LEX
AC_PROG_YACC
AM_PROG_LIBTOOL



dnl Now begin Checking for various libraries
dnl ==================================================================


dnl Test for libjpeg 
dnl ==================================================================
AC_CHECK_LIB(jpeg, jpeg_read_header, 
    AC_CHECK_HEADER(jpeglib.h, 
	have_jpeg=yes, have_jpeg=no
    )
)

dnl Test for libpng and zlib
dnl ==================================================================
AC_CHECK_LIB(png, png_read_info,
    AC_CHECK_HEADER(zlib.h,
	AC_CHECK_HEADER(png.h, 
	    have_png=yes, have_png=no)
    ), , -lz -lm
)

dnl Now test for a bunch of C++ compiler capabilities...
dnl ==================================================================
AC_PROG_CXX
AC_LANG_CPLUSPLUS


dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports bool(required))
AC_TRY_COMPILE(
[
],[
   bool b=true;
   bool b1=false;
],[
  ac_bool=yes
dnl  AC_DEFINE(HAVE_NATIVE_BOOL)
],[
  config_error=yes
  AC_WARN(bool type is not supported by your compiler)
])
AC_MSG_RESULT([$ac_bool])

dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports const_cast (required))
AC_TRY_COMPILE(
[
   class foo;
],[
   const foo *c=0;
   foo *c1=const_cast<foo*>(c);
],[
  ac_const_cast=yes
dnl  AC_DEFINE(HAVE_CONST_CAST)
],[
  AC_WARN(C++ compiler const_cast<> does not work)
  config_error=yes
])
AC_MSG_RESULT([$ac_const_cast])




dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports member templates)
AC_TRY_COMPILE(
[
class foo
{
public:
  template <class T> void method(T t);
};

template <class T> void foo::method(T t) {t = 0;}
],[
],[
   ac_member_templates=yes
dnl   AC_DEFINE(HAVE_MEMBER_TEMPLATES)
   AC_MSG_RESULT([$ac_member_templates])
],[
  ac_member_templates=no
  AC_MSG_RESULT([$ac_member_templates])
  AC_MSG_WARN([Test for member templates failed. If your compiler does support member templates, see config.log to figure out why the test failed.])
])



dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports partial specialization)
AC_TRY_COMPILE(
[
template<class T, class K>
class k {
public:
};
template<class T> class k<void,T> { };
],[
  k<float, float> b;
  k<void,void> a;
],[
  ac_partial_specialization=yes
dnl  AC_DEFINE(HAVE_PARTIAL_SPECIALIZATION)
],[
  ac_partial_specialization=no
])
AC_MSG_RESULT([$ac_partial_specialization])


dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports static data inside templates)
AC_TRY_LINK(
[
template<class T>
class foo { public: static T a; };
template<class T>
static T foo<T>::a=0;
],[
  foo<int> b;
],[
  ac_static_templates=yes
],[
dnl  AC_DEFINE(HAVE_NO_STATIC_TEMPLATES)
  ac_static_templates=no
])
AC_MSG_RESULT([$ac_static_templates])


dnl ==================================================================
AC_MSG_CHECKING(if C++ compiler supports templates well enough(required))
AC_TRY_LINK(
[
class foo { public: int a(float,int,int,foo*,foo**) { return 0; } };
template<class rettype, class T, class P1, class P2, class P3, class P4, class P5>
class k {
public:
   rettype (T::*method)(P1,P2,P3,P4,P5);
};
],[
  k<int,foo,float,int,int,foo*,foo**> a;
],[
],[
  config_error=yes
  AC_WARN(your C++ compiler does not support templates well enough)
])
AC_MSG_RESULT([yes])


dnl ==================================================================
AC_MSG_CHECKING(if required compiler features are available)
if test "x$config_error" = xyes ; then
  AC_MSG_RESULT([no])
  AC_MSG_ERROR(Your compiler is not powerful enough to compile libVrml97. If you think that that your compiler is powerful enough, then see config.log for more information about why things failed.)
fi
AC_MSG_RESULT([yes])

CFLAGS=""
JSCFLAGS="-DXP_UNIX"

dnl Debug or not
AC_ARG_ENABLE(debug, [  --enable-debug ])
if test "${enable_debug}" = "yes"; then
  CFLAGS="$CFLAGS -g"
else
  CFLAGS="$CFLAGS -DNDEBUG"
fi

dnl Optimized or not
AC_ARG_ENABLE(optimized, [  --disable-optimized ])
if test "${enable_optimized}" != "no"; then
  CFLAGS="$CFLAGS -O2"
fi

AC_SUBST(CFLAGS)
AC_SUBST(JSCFLAGS)
AC_SUBST(JPEG_LIBS)
AC_SUBST(PNG_LIBS)

AC_OUTPUT(Makefile \
          src/Makefile \
          src/vrml97/Makefile \
          src/vrml97/libjs/Makefile
          src/vrml97/libjs/fdlibm/Makefile)

